{
	"nodes":[
		{"id":"0f60de72b746fb0f","type":"text","text":"```\nif(myVar == 0){\n\tfunct();\n}else{\n\tfunct();\n}\n\nint mayor = (x > y ? x : y);\n```\n\n```\nswitch(x){\n\tcase 1:\n\t\tbreak;\n\tcase 2:{\n\t\tint a = 12;\n\t}\n\tcase 3:\n\t\tbreak\n\tdefault:\n\t\tfunct();\n}\n```\n\n```\nwhile(x>10){...}\n```\n\n```\ndo{...}while(condicion);\n```\n\n```\nfor(int i = 0; i < 23; i++){...}\n```\n\n```\nlabel:\n(codigo...)\n\ngoto label;\n```","x":-2275,"y":320,"width":520,"height":890},
		{"id":"980c28d605817a41","type":"text","text":"`#include <stdalign.h>`\n\n``alignas(16) int x;``\n``alignas(4) char myChar;``\n``alignas(64) struct``\n\n`int myVarAlign = alignof(myVar);`\n`int intAlign = alignof(int);`\n\n``typedef alignas(16) struct {...} structName;``","x":-2235,"y":-540,"width":460,"height":280},
		{"id":"62a31604e5a8ba08","type":"text","text":"``auto int x;`` es lo mismo que ``int x;``\n`register int myRegVar;`\n\n``static int fileStaticVar;``\n\nstatic int myStaticFunct(){\nstatic int myStaticPersistVar;\n}\n\n\n\n// File1.c\n``const double myVar = 9.88;``\n\n// File2.c\n``extern const double myVar;`` => Referencia a la variable declarada en otro archivo.","x":-2235,"y":-160,"width":480,"height":380},
		{"id":"c3108509f396da44","type":"text","text":"**> Modificadores de tipo**\n\n* **signed**\n\tUtilizada para definir que la variable debe tener signo (puede albergar valores positivos y negativos).\n* **unsigned**\n\tUtilizada para definir que la variable no puede tener signo (solo admite valores positivos).\n* **long**\n\tUtilizada para defnir que se use una version de la variable larga (tambien se puede usar long long, por ejemplo: **long long int**).\n* **short**\n\tUtilizada para defnir que se usa una version corta de la variable (por ejemplo, un int generamente son 4 bytes, asi que un short int generalmente son 2 bytes).","x":-1655,"y":1260,"width":780,"height":380},
		{"id":"76e3cbdeec8411b7","type":"text","text":"**> Otras palabras reservadas**\n\n* **typedef**\n\tSirve para definir un tipo de dato creado por el usuario (generalmente alias).\n* **typeof(x)** (C23)\n\tSirve para obtener el tipo de dato de una variable.\n* **sizeof(x)**\n\tDevuelve el tamaño en bytes de su argumento.\n* **constexpr** (C23)\n\tHace que la linea que contiene su declaracion sea compilada y guardada su valor en el codigo de forma constante.\n* **inline** (C99)\n\tSirve para definir que una funcion es inline, lo que hace que cada vez que se llame, internamente se reemplace su llamado por el cuerpo de la funcion.\n* **nullptr** (C99)\n\tValor nulo.\n* **static_assert** (C23)\n\tSe hace un assert PERO a diferencia del assert de la libreria, este se evalua en tiempo de compilacion y no en ejecucion.\n* **thread_local** (C23)\n\tTipo de dato utilizado para definir copias unicas de una variable por hilo de ejecucion.\n* **typeof_unqual** (C23)\n\tLo mismo que typeof, pero este remueve los calificadores de tipo.","x":-855,"y":1400,"width":660,"height":660},
		{"id":"f299a149018c2211","type":"text","text":"**> Alineacion de linea de cache**\n\n* **alignas(x)**\n\tSe utiliza para definir la alineacion en la linea de cache de un programa sobre la variable a la que se le aplica. Debe ser igual o mayor que la alineacion por defecto que tiene la variable a la que le esta haciendo efecto. Solo admite potencias binarias en su valor de entrada (1,2,4,8,16,32,64,128,etc).\n* **alignof(x)**\n\tDevuelve el valor de alineacion de un tipo o de una variable que se le pasa como argumento.\n\n**Necesitas la inclusion de esta libreria:** (C23)\n\t**`#include <stdalign.h>`**","x":-1655,"y":-540,"width":780,"height":340},
		{"id":"5c668951377caac0","type":"text","text":"**> Almacenamiento de variables**\n\n* **auto**\n\tSe usa para definir que una variable solo puede ser accedida desde el bloque donde es declarada y bloques internos a ese bloque. Es el tipo de especificador de almacenamiento por defecto.\n* **register**\n\tSe usa para decirle al compilador que en caso de ser posible almacene esa variable dentro de un registro del procesador y no dentro de la memoria RAM, al final el compilador es el que se encarga de realizar la optimizacion, en caso de no poder la variable simplemente se guardara en RAM. Cual quiera que sea el caso, no se puede acceder a la direccion de memoria de la variable declarada como register.\n* **static**\n\tSe usa en 2 contextos diferentes: Para declarar una variable con persistencia en memoria dentro de una funcion. Para declarar que una variable/funcion es unica del archivo donde se declara y por lo cual no puede ser accedida desde un archivo externo.\n* **extern**\n\tSe usa para decirle al compilador que no cree la variable porque ya esta declarada en algun lado de algun otro archivo, por lo que solo utilice su referencia. Sirve para utilizar variables entre diferentes archivos (tambien sirve con funciones);","x":-1655,"y":-180,"width":780,"height":520},
		{"id":"fa1436b39cd15649","type":"text","text":"**> Bloques de control / Estructuras de control**\n\n* **if**\n\tCondicional simple de C.\n* **else**\n\tCondicional que se activa cuando la condicional anterior no se cumplio.\n* **Operador Ternario (cond ? si : no) **\n\tCondicional base if/else en linea simple.\n********\n* **switch**\n\tBloque de codigo que funciona como una condicional (con valores numericos o caracteres).\n* **case**\n\tCondicional aplicada al switch.\n* **default**\n\tCaso final del switch, si ningun case se cumple entonces cae aqui\n\n***********\n* **while**\n\tBucle while basico, se seguira ejecutando mientras la condicion sea verdadera.\n* **do (do-while)**\n\tBucle while PERO en este bucle siempre corre al menos una vez, las demas iteraciones se daran siempre y cuando su condicion sea verdadera.\n* **for**\n\tBucle for simple, requiere 3 parametros (aunque no son obligatorios): inicializacion, condicion y seccion de post-iteracion.\n*************\n* **goto**\n\tFunciona poniendo el nombre de una label, por ejemplo goto start, esto hara que se salte a esa parte del codigo.","x":-1655,"y":360,"width":780,"height":880},
		{"id":"3c795b424b70887b","type":"text","text":"**> Valores booleanos (en C no exisyen sin usar STD Bool)**\n\n* **bool**\n\tTipo de dato utilizado para declarar un booleano.\n* **true**\n\tValor de verdad (generalmente representa 1 o un numero diferente de 0)\n* **false**\n\tValor de falsedad (generalmente representa un 0)\n\n**Necesitas la inclusion de esta libreria:** (C23)\n**`#include <stdbool.h>`**","x":-855,"y":-540,"width":660,"height":340},
		{"id":"d27c7bcfa8cabe5f","type":"text","text":"**> Continuidad de codigo**\n\n* **break**\n\tSe utiliza para romper continuidad en bloques de control (como while, do while, for, switch). Hace que se salga del bloque y se continue a la siguiente instruccion. En switch hace que una vez dentro de un case se termine saliendo de ese case sin verificar los demas.\n* **continue**\n\tSe utiliza para ir a la verificacion de la condicion del bloque (while, do while, for). En general se usa para ir a la siguiente iteracion del bloque.\n* **return**\n\tSe utiliza para salir de una funcion retornando un valor (en caso de que la funcion permita un retorno).","x":-855,"y":-180,"width":660,"height":380},
		{"id":"3c352eca36e71ef9","type":"text","text":"**> Tipos de datos primitivos**\n\n* **char**\n\tTipo de dato para guardar caracteres, generalmente 1 byte. (un caracter tiene una forma asi: 'x').\n* **int**\n\tTipo de dato para un numero entero.\n* **float**\n\tTipo de dato para un numero con parte decimal.\n* **double**\n\tTipo de dato para un numero con parte decimal (mas preciso y mas grande).\n* **void**\n\tTipo de dato generico, utilizado en manipulacion de punteros y variables de funciones, arrays de funciones, templates, etc.","x":-855,"y":220,"width":660,"height":400},
		{"id":"737bbb2098fd79fb","type":"text","text":"**> Calificadores de tipo**\n\n* **const**\n\tSe usa para definir que una variable no puede ser modificada por el programa (pero podria ser por algo externo).\n* **volatile**\n\tSe usa para decirle al compilador que no optimice esta variable porque posiblemente su valor puede ser modificado por otro proceso/programa/hardware.\n* **restrict** (C99)\n\tSe utiliza para decirle al compilador que ese puntero es la unica forma en que es accesible esa direccion de memoria. Como tal no hace nada, es mas una promesa para que el compilador pueda hacer optimizaciones sobre ese puntero.","x":-855,"y":640,"width":660,"height":380},
		{"id":"fdcde377ba24196e","type":"text","text":"**> Tipos de datos mas complejas (definidos por el usuario)**\n\n* **enum**\n\tUtilizado para crear enumeraciones con nombres para cada uno de sus miembros.\n* **struct**\n\tUtilizado para crear una variable capaz de guardar muchas variables juntas, su tamaño es igual al tamaño de todos sus miembros sumados.\n* **union**\n\tUtilizado para crear una variable capaz de guardar muchas variables juntas PERO solo puede usar uno de sus miembros a la vez. El tamaño de una union es igual al tamaño del tipo de dato mas grande de sus miembros.","x":-855,"y":1040,"width":660,"height":340},
		{"id":"5fe4440904207e8e","type":"text","text":"Los campos de bits se pueden crear de la siguiente manera:\n\n`{signed o unsigned} {fieldName}: {bits number}`\npor ejemplo:\n`unsigned bit0: 1;`\n\nSolo las estructuras pueden tener campos de bits.","x":-135,"y":1070,"width":500,"height":280},
		{"id":"3e31f00885d730c0","type":"text","text":"```\n#include <stdbool.h>\n\nint main(){\n    bool myBool;\n    myBool = false;\n    myBool = true;\n}\n```","x":-115,"y":-520,"width":380,"height":240},
		{"id":"1fb763c1b687d159","type":"text","text":"<h1> Comentarios en C</h1>\n\nEstilo C:\n```\n/* Esto es un comentario */\n/* Pueden\nser multi\nlinea*/\n```\n\nEstilo C++:\n```\n// Este es comentario tipo C++\n// Son uni-linea\n```\n\nSe pueden mezclar estos 2 tipos de comentarios","x":-2235,"y":-1300,"width":415,"height":440},
		{"id":"ce316a133efb3224","type":"text","text":"<center><h1>Palabras Reservadas</h1></center>","x":-1655,"y":-700,"width":355,"height":100},
		{"id":"a22c1ac84720a43c","type":"text","text":"<center><h1>Simbolos de puntuacion</h1></center>\n\n```\n{}   Sirve para definir bloques de codigo, inicializaciones, etc.\n\t\tEn estructuras y uniones, delimita la lista de declaracion de sus miembros\n\t\tEn enums, delimita las declaraciones de sus enumeraciones\n\t\tCrea las declaraciones compuestas (compound statement) usadas en if's y demas bloques\n\t\tSirve para definir la lista de inicializadores:\n\t\t\tint x[] = {1,2,3,4,5};\n\t\t    int x[] = { 1, 3, 5 }, *p = x;\n\t\t    struct {int a[3], b;} w[] = {[0].a = {1}, [1].a[0] = 2};\n\t\t    \n[]   Subscript Operator, declarador de arreglo, en inicializaciones y en especificadores de atributos\n\t\tSubscript Operator es lo que se usa para acceder los elementos a travez de un indice:\n\t\t\tint x = myArray[1];\n\t\tPara declarar arreglos y declaraciones en general\n\t\t\tInicializa solo el tercer elemento (indice 2) y el ultimo int:\n\t\t\t\tarr[10] = { [2] = 10, [9] = 20 };\n\t\tPara establecer atributos:\n\t\t\t[[ deprecated ]] void mi_funcion(void);\n\t\t\tLo de arriba hara que el compilador marque advertencias si se usa esa funcion\n\t\t\n#    Operador para el preprocesador\n\t\tSe puede usar para definir la utilizacion de una funcion del preprocesador:\n\t\t\t#define TRUE 1\n\t\tSe puede usar para convertir a cadena parametros usados en macros para el preprocesador:\n\t\t\t#define myPrint(variable) \\\n\t\t\t\tprintf(\"Argumento es: \" variable \"\\n\")\n\t\t\tEl compilador concatena cualquier texto de cadena que se encuentre contiguo\n\t\t\n##   Operador de token pasting para el preprocesador\n\t\tPuede tener usos interesantes para la fase del preprocesado:\n\t\t\t#define createPrintFunction(type,format) \\\n\t\t\t\tvoid print_##type(type variable){ \\\n\t\t\t\t\tprintf(\"The value is: %\" #format, variable); \\\n\t\t\t\t}\n\t\t\t\n\t\t\tY luego se puede usar en el codigo como:\n\t\t\t\tcreatePrintFunction(int,i);\n```","x":-1660,"y":-2120,"width":1035,"height":1040}
	],
	"edges":[
		{"id":"ee259dd2b67ec9c6","fromNode":"f299a149018c2211","fromSide":"left","toNode":"980c28d605817a41","toSide":"right"},
		{"id":"aeabc721262c48c1","fromNode":"fdcde377ba24196e","fromSide":"right","toNode":"5fe4440904207e8e","toSide":"left"},
		{"id":"22dcfeb188645ed8","fromNode":"5c668951377caac0","fromSide":"left","toNode":"62a31604e5a8ba08","toSide":"right"},
		{"id":"6ce629fe73fb2227","fromNode":"3c795b424b70887b","fromSide":"right","toNode":"3e31f00885d730c0","toSide":"left"},
		{"id":"31e6cdebbeb02b2a","fromNode":"fa1436b39cd15649","fromSide":"left","toNode":"0f60de72b746fb0f","toSide":"right"}
	]
}