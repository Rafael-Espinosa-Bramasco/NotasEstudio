{
	"nodes":[
		{"id":"0f60de72b746fb0f","type":"text","text":"```\nif(myVar == 0){\n\tfunct();\n}else{\n\tfunct();\n}\n\nint mayor = (x > y ? x : y);\n```\n\n```\nswitch(x){\n\tcase 1:\n\t\tbreak;\n\tcase 2:{\n\t\tint a = 12;\n\t}\n\tcase 3:\n\t\tbreak\n\tdefault:\n\t\tfunct();\n}\n```\n\n```\nwhile(x>10){...}\n```\n\n```\ndo{...}while(condicion);\n```\n\n```\nfor(int i = 0; i < 23; i++){...}\n```\n\n```\nlabel:\n(codigo...)\n\ngoto label;\n```","x":-2275,"y":320,"width":520,"height":890},
		{"id":"980c28d605817a41","type":"text","text":"`#include <stdalign.h>`\n\n``alignas(16) int x;``\n``alignas(4) char myChar;``\n``alignas(64) struct``\n\n`int myVarAlign = alignof(myVar);`\n`int intAlign = alignof(int);`\n\n``typedef alignas(16) struct {...} structName;``","x":-2235,"y":-540,"width":460,"height":280},
		{"id":"62a31604e5a8ba08","type":"text","text":"``auto int x;`` es lo mismo que ``int x;``\n`register int myRegVar;`\n\n``static int fileStaticVar;``\n\nstatic int myStaticFunct(){\nstatic int myStaticPersistVar;\n}\n\n\n\n// File1.c\n``const double myVar = 9.88;``\n\n// File2.c\n``extern const double myVar;`` => Referencia a la variable declarada en otro archivo.","x":-2235,"y":-160,"width":480,"height":380},
		{"id":"c3108509f396da44","type":"text","text":"**> Modificadores de tipo**\n\n* **signed**\n\tUtilizada para definir que la variable debe tener signo (puede albergar valores positivos y negativos).\n* **unsigned**\n\tUtilizada para definir que la variable no puede tener signo (solo admite valores positivos).\n* **long**\n\tUtilizada para defnir que se use una version de la variable larga (tambien se puede usar long long, por ejemplo: **long long int**).\n* **short**\n\tUtilizada para defnir que se usa una version corta de la variable (por ejemplo, un int generamente son 4 bytes, asi que un short int generalmente son 2 bytes).","x":-1655,"y":1260,"width":780,"height":380},
		{"id":"76e3cbdeec8411b7","type":"text","text":"**> Otras palabras reservadas**\n\n* **typedef**\n\tSirve para definir un tipo de dato creado por el usuario (generalmente alias).\n* **typeof(x)** (C23)\n\tSirve para obtener el tipo de dato de una variable.\n* **sizeof(x)**\n\tDevuelve el tamaño en bytes de su argumento.\n* **constexpr** (C23)\n\tHace que la linea que contiene su declaracion sea compilada y guardada su valor en el codigo de forma constante.\n* **inline** (C99)\n\tSirve para definir que una funcion es inline, lo que hace que cada vez que se llame, internamente se reemplace su llamado por el cuerpo de la funcion.\n* **nullptr** (C99)\n\tValor nulo.\n* **static_assert** (C23)\n\tSe hace un assert PERO a diferencia del assert de la libreria, este se evalua en tiempo de compilacion y no en ejecucion.\n* **thread_local** (C23)\n\tTipo de dato utilizado para definir copias unicas de una variable por hilo de ejecucion.\n* **typeof_unqual** (C23)\n\tLo mismo que typeof, pero este remueve los calificadores de tipo.","x":-855,"y":1400,"width":660,"height":660},
		{"id":"f299a149018c2211","type":"text","text":"**> Alineacion de linea de cache**\n\n* **alignas(x)**\n\tSe utiliza para definir la alineacion en la linea de cache de un programa sobre la variable a la que se le aplica. Debe ser igual o mayor que la alineacion por defecto que tiene la variable a la que le esta haciendo efecto. Solo admite potencias binarias en su valor de entrada (1,2,4,8,16,32,64,128,etc).\n* **alignof(x)**\n\tDevuelve el valor de alineacion de un tipo o de una variable que se le pasa como argumento.\n\n**Necesitas la inclusion de esta libreria:** (C23)\n\t**`#include <stdalign.h>`**","x":-1655,"y":-540,"width":780,"height":340},
		{"id":"5c668951377caac0","type":"text","text":"**> Almacenamiento de variables**\n\n* **auto**\n\tSe usa para definir que una variable solo puede ser accedida desde el bloque donde es declarada y bloques internos a ese bloque. Es el tipo de especificador de almacenamiento por defecto.\n* **register**\n\tSe usa para decirle al compilador que en caso de ser posible almacene esa variable dentro de un registro del procesador y no dentro de la memoria RAM, al final el compilador es el que se encarga de realizar la optimizacion, en caso de no poder la variable simplemente se guardara en RAM. Cual quiera que sea el caso, no se puede acceder a la direccion de memoria de la variable declarada como register.\n* **static**\n\tSe usa en 2 contextos diferentes: Para declarar una variable con persistencia en memoria dentro de una funcion. Para declarar que una variable/funcion es unica del archivo donde se declara y por lo cual no puede ser accedida desde un archivo externo.\n* **extern**\n\tSe usa para decirle al compilador que no cree la variable porque ya esta declarada en algun lado de algun otro archivo, por lo que solo utilice su referencia. Sirve para utilizar variables entre diferentes archivos (tambien sirve con funciones);","x":-1655,"y":-180,"width":780,"height":520},
		{"id":"fa1436b39cd15649","type":"text","text":"**> Bloques de control / Estructuras de control**\n\n* **if**\n\tCondicional simple de C.\n* **else**\n\tCondicional que se activa cuando la condicional anterior no se cumplio.\n* **Operador Ternario (cond ? si : no) **\n\tCondicional base if/else en linea simple.\n********\n* **switch**\n\tBloque de codigo que funciona como una condicional (con valores numericos o caracteres).\n* **case**\n\tCondicional aplicada al switch.\n* **default**\n\tCaso final del switch, si ningun case se cumple entonces cae aqui\n\n***********\n* **while**\n\tBucle while basico, se seguira ejecutando mientras la condicion sea verdadera.\n* **do (do-while)**\n\tBucle while PERO en este bucle siempre corre al menos una vez, las demas iteraciones se daran siempre y cuando su condicion sea verdadera.\n* **for**\n\tBucle for simple, requiere 3 parametros (aunque no son obligatorios): inicializacion, condicion y seccion de post-iteracion.\n*************\n* **goto**\n\tFunciona poniendo el nombre de una label, por ejemplo goto start, esto hara que se salte a esa parte del codigo.","x":-1655,"y":360,"width":780,"height":880},
		{"id":"3c795b424b70887b","type":"text","text":"**> Valores booleanos (en C no exisyen sin usar STD Bool)**\n\n* **bool**\n\tTipo de dato utilizado para declarar un booleano.\n* **true**\n\tValor de verdad (generalmente representa 1 o un numero diferente de 0)\n* **false**\n\tValor de falsedad (generalmente representa un 0)\n\n**Necesitas la inclusion de esta libreria:** (C23)\n**`#include <stdbool.h>`**","x":-855,"y":-540,"width":660,"height":340},
		{"id":"d27c7bcfa8cabe5f","type":"text","text":"**> Continuidad de codigo**\n\n* **break**\n\tSe utiliza para romper continuidad en bloques de control (como while, do while, for, switch). Hace que se salga del bloque y se continue a la siguiente instruccion. En switch hace que una vez dentro de un case se termine saliendo de ese case sin verificar los demas.\n* **continue**\n\tSe utiliza para ir a la verificacion de la condicion del bloque (while, do while, for). En general se usa para ir a la siguiente iteracion del bloque.\n* **return**\n\tSe utiliza para salir de una funcion retornando un valor (en caso de que la funcion permita un retorno).","x":-855,"y":-180,"width":660,"height":380},
		{"id":"3c352eca36e71ef9","type":"text","text":"**> Tipos de datos primitivos**\n\n* **char**\n\tTipo de dato para guardar caracteres, generalmente 1 byte. (un caracter tiene una forma asi: 'x').\n* **int**\n\tTipo de dato para un numero entero.\n* **float**\n\tTipo de dato para un numero con parte decimal.\n* **double**\n\tTipo de dato para un numero con parte decimal (mas preciso y mas grande).\n* **void**\n\tTipo de dato generico, utilizado en manipulacion de punteros y variables de funciones, arrays de funciones, templates, etc.","x":-855,"y":220,"width":660,"height":400},
		{"id":"737bbb2098fd79fb","type":"text","text":"**> Calificadores de tipo**\n\n* **const**\n\tSe usa para definir que una variable no puede ser modificada por el programa (pero podria ser por algo externo).\n* **volatile**\n\tSe usa para decirle al compilador que no optimice esta variable porque posiblemente su valor puede ser modificado por otro proceso/programa/hardware.\n* **restrict** (C99)\n\tSe utiliza para decirle al compilador que ese puntero es la unica forma en que es accesible esa direccion de memoria. Como tal no hace nada, es mas una promesa para que el compilador pueda hacer optimizaciones sobre ese puntero.","x":-855,"y":640,"width":660,"height":380},
		{"id":"fdcde377ba24196e","type":"text","text":"**> Tipos de datos mas complejas (definidos por el usuario)**\n\n* **enum**\n\tUtilizado para crear enumeraciones con nombres para cada uno de sus miembros.\n* **struct**\n\tUtilizado para crear una variable capaz de guardar muchas variables juntas, su tamaño es igual al tamaño de todos sus miembros sumados.\n* **union**\n\tUtilizado para crear una variable capaz de guardar muchas variables juntas PERO solo puede usar uno de sus miembros a la vez. El tamaño de una union es igual al tamaño del tipo de dato mas grande de sus miembros.","x":-855,"y":1040,"width":660,"height":340},
		{"id":"5fe4440904207e8e","type":"text","text":"Los campos de bits se pueden crear de la siguiente manera:\n\n`{signed o unsigned} {fieldName}: {bits number}`\npor ejemplo:\n`unsigned bit0: 1;`\n\nSolo las estructuras pueden tener campos de bits.","x":-135,"y":1070,"width":500,"height":280},
		{"id":"3e31f00885d730c0","type":"text","text":"```\n#include <stdbool.h>\n\nint main(){\n    bool myBool;\n    myBool = false;\n    myBool = true;\n}\n```","x":-115,"y":-520,"width":380,"height":240},
		{"id":"1fb763c1b687d159","type":"text","text":"<h1> Comentarios en C</h1>\n\nEstilo C:\n```\n/* Esto es un comentario */\n/* Pueden\nser multi\nlinea*/\n```\n\nEstilo C++:\n```\n// Este es comentario tipo C++\n// Son uni-linea\n```\n\nSe pueden mezclar estos 2 tipos de comentarios","x":-2235,"y":-1300,"width":415,"height":440},
		{"id":"ce316a133efb3224","type":"text","text":"<center><h1>Palabras Reservadas</h1></center>","x":-1655,"y":-700,"width":355,"height":100},
		{"id":"1401e9a83c6258f6","x":-340,"y":-760,"width":630,"height":160,"type":"text","text":"<h1><center><b>Funcion Main</b></center></h1>\n\nint main(int argc, char* argv[], char* envp[]){}\n\nEstos argumentos pueden ser omitidos"},
		{"id":"a22c1ac84720a43c","type":"text","text":"<center><h1>Simbolos de puntuacion</h1></center>\n\n```\n{}   Sirve para definir bloques de codigo, inicializaciones, etc.\n\t\tEn estructuras y uniones, delimita la lista de declaracion de sus miembros\n\t\tEn enums, delimita las declaraciones de sus enumeraciones\n\t\tCrea las declaraciones compuestas (compound statement) usadas en if's y demas bloques\n\t\tSirve para definir la lista de inicializadores:\n\t\t\tint x[] = {1,2,3,4,5};\n\t\t    int x[] = { 1, 3, 5 }, *p = x;\n\t\t    struct {int a[3], b;} w[] = {[0].a = {1}, [1].a[0] = 2};\n\t\t    \n[]   Subscript Operator, declarador de arreglo, en inicializaciones y en especificadores de atributos\n\t\tSubscript Operator es lo que se usa para acceder los elementos a travez de un indice:\n\t\t\tint x = myArray[1];\n\t\tPara declarar arreglos y declaraciones en general\n\t\t\tInicializa solo el tercer elemento (indice 2) y el ultimo int:\n\t\t\t\tarr[10] = { [2] = 10, [9] = 20 };\n\t\tPara establecer atributos:\n\t\t\t[[ deprecated ]] void mi_funcion(void);\n\t\t\tLo de arriba hara que el compilador marque advertencias si se usa esa funcion\n\t\t\n#    Operador para el preprocesador\n\t\tSe puede usar para definir la utilizacion de una funcion del preprocesador:\n\t\t\t#define TRUE 1\n\t\tSe puede usar para convertir a cadena parametros usados en macros para el preprocesador:\n\t\t\t#define myPrint(variable) \\\n\t\t\t\tprintf(\"Argumento es: \" #variable \"\\n\")\n\t\t\tEl compilador concatena cualquier texto de cadena que se encuentre contiguo\n\t\t\n##   Operador de token pasting para el preprocesador\n\t\tPuede tener usos interesantes para la fase del preprocesado:\n\t\t\t#define createPrintFunction(type,format) \\\n\t\t\t\tvoid print_##type(type variable){ \\\n\t\t\t\t\tprintf(\"The value is: %\" #format, variable); \\\n\t\t\t\t}\n\t\t\t\n\t\t\tY luego se puede usar en el codigo como:\n\t\t\t\tcreatePrintFunction(int,i);\n\n()   Operador parentesis / operador agrupacion\n\t\tEn una expresion indica agrupacion\n\t\tOperador de llamada a funcion\n\t\tEn sizeof, alignof y typeof delimita el operando\n\t\tEn el casteo explicito delimita el id del tipo\n\t\tEn un literal compuesto, limita el id del tipo\n\t\t\tstruct Punto { int x, y; };\n\t\t\tstruct Punto p = (struct Punto){ .x = 10, .y = 20 };\n\t\tEn una funcion, delimita la declaracion de parametros\n\t\tEn estructuras de control delimita la clausula de control\n\n:    Operador dos puntos\n\t\tParte del operador condicional\n\t\tParte de la declaracion de etiquetas\n\t\tEn los campos de bits se introduce el tamaño\n\n...  Operador de puntos\n\t\tSe usa en la definicion de parametros de funciones para definir una funcion varidica (que sus argumentos pueden variar) (stdarg.h)\n\t\tSe usa en la definicion de parametros de funciones en Macros (usando __VA_ARGS__)\n\n;\t Operador de punto y coma\n\t\tDeclara el final de una sentencia\n\t\tDeclara el final de una declaracion\n\t\tSepara las partes de una declaracion 'for'\n\n?    Operador de condicional en operaciones ternarias\n\t\tSe usa en la condicional:\n\t\t\tbool x = (cond ? true : false);\n\n::   En C, se usa de dos formas\n\t\tEn atributos:\n\t\t\t[[gnu::unused]] int x;   Esto indica que ese atributo llamado unused pertenece al contexto o namespace gnu\n\t\tEn preprocesador permite declarar namespace:\n\t\t\t#embed <logo.png> as logo::data     Esto indica que data (el nombre que se le da) pertenece al namespace logo\n\n.    Operador punto\n\t\tSe usa como operador de acceso de miembros\n\t\tSe usa para acceder a los miembros desde su declaracion:\n\t\t\tstruct Punto p = { .y = 42, .x = 7 };\n\n->   Operador flecha\n\t\tSe usa para acceder a los miembros de un objeto/estructura que sea puntero\n\n~    Operador unario del complemento (bitwise NOT operator)\n\n!    Operador logico NOT (no confundir con el operador a nivel de bit)\n\n+    Operador de MAS\n\t\tOperador unario: Se usa para especificar que un valor se tome como positivo:\n\t\t\tint x = +7;\n\t\tOperador binario: Se usa para hacer una suma:\n\t\t\tint x = 5 + 7;\n\n-    Operador de MENOS\n\t\tBasicamente lo mismo que el de MAS, pero para numeros negativos\n\n*    Operador asterisco\n\t\tOperador de desreferenciacion\n\t\tOperador de multiplicacion\n\t\tOperador para declarar un puntero\n\t\tOperador para declarar arreglo dinamicamente en funciones:\n\t\t\tvoid foo(int n, int a[*]){...}   Se usa cuando se tiene un numero pasado a la funcion que indica su tamaño\n\n/    Operador de division\n\n%    Operador de modulo\n\n^    Operador XOR a nivel de bits (bitwise XOR)\n\n&    Operador AND\n\t\tOperador de direcciones (address)\n\t\tOperador AND a nivel de bits (bitwise AND operator)\n\n|    Operador OR a nivel de bits (bitwise OR)\n\n=    Operador igual\n\t\tOperador de asignacion simple\n\t\tEn inicializaciones, delimita el objeto y la lista de inlicializacion\n\t\tEn los enums, define el valor de la constante\n\n+= , -= , *= , /= , %= , ^= , &= , |=\n\tOperadores de asignacion compuestos, realizan operaciones como:\n\t\tint x += 8;  Esto seria igual a x = x + 8\n\n== , !=\n\tOperadores de comparacion de igualdad:\n\t\t== Significa igual a \n\t\t!= Diferente de\n\n< , > , <= , >=\n\tOperadores de comparacion: Menor que, mayor que, menor o igual que, mayor o igual que\n\n&& , ||\n\tOperador AND y OR a nivel logico\n\n<< , >> , <<= , >>=\n\tOperadores de desplazamiento a nivel de bits (bitwise shift operators)\n\tx >> 1 esto divide entre 2\n\tx << 1 esto multiplica por 2\n\n++ , --\n\tOperadores de incremento y decremento, son unarios.\n\tDepende mucho en donde los uses:\n\t\tAntes de la variable, primero haran su trabajo y despues evaluan la variable\n\t\tDespues de la variable, primero evaluan y despues hacen su trabajo\n\n,    Operador coma\n\tSeparador general en muchos ambitos\n\n```","x":480,"y":-800,"width":1260,"height":3640},
		{"id":"bd17f32618885df4","x":-1655,"y":-1700,"width":1140,"height":960,"type":"text","text":"<h1><b><center>Directivas del Preprocesador</center></b></h1>\n\n```\n#if\n#ifdef\n#ifndef\n#elif\n#elifdef\n#elifndef\n#endif\n\nfuncion defined() para cuando necesitas checar mas de una definicion\n\t#if defined(x) && defined(y)\n\n#define\n#\n##\n\n#include\n#pragma\n\tonce -> para decir que ese archivo solo se incluya una vez\n#line\n\tCambia la linea en la que se encuentra\n#error\n\tSe salta un error\n#warning\n\tSe salta una advertencia\n#embed\n\tSe usa para incluir archivos binarios en el codigo directamente\n\t\tconst char message[] =\n\t\t{\n\t\t\t#embed \"message.txt\" if_empty('M', 'i', 's', 's', 'i', 'n', 'g', '\\n')\n\t\t\t,'\\0' // null terminator\n\t\t};\n\t\tconst uint8_t image_data[] =\n\t\t{\n\t\t\t#embed \"image.png\"\n\t\t};\n```"},
		{"id":"1d698856fa3a0f05","x":-460,"y":-1160,"width":1245,"height":320,"type":"text","text":"<center><h1>Categorias de Valores</h1></center>\n\n<h4>LValue</h4>\n\nLocator Value (tambien conocido como Left Value) es la parte de la expresion a la que le puedes tomar direccion de memoria.\n\n<h4>RValue</h4>\n\nRight value es el valor que se encuentra del lado derecho de una expresion, valores constantes generalmente"},
		{"id":"0793390b88ceabff","x":-460,"y":-1580,"width":435,"height":380,"type":"text","text":"<center><h1>Constantes y Literales</h1></center>\n\nEnteros:\n* u / U\n\t* unsigned\n* l / L\n\t* long\n* ll / LL\n\t* long long\n* wb / WB\n\t* Para enteros de ancho arbitrario ( \\_BitInt(n) )"},
		{"id":"4f2dfb638d7c7ce2","x":0,"y":-1600,"width":405,"height":400,"type":"text","text":"Flotantes:\n\n* e / E\n\t* Para declarar un exponente\n\t\t\t123e3 => 123\\*10^3\n* p / P\n\t* Para declarar un exponente binario\n\t\t\t12p5 => 12\\*2^5\n* df / DF\n\t* \\_Decimal32\n* dd / DD\n\t* \\_Decimal64\n* dl / DL\n\t* \\_Decimal128"},
		{"id":"d47d4e11ca31da59","x":1080,"y":-1160,"width":660,"height":320,"type":"text","text":"<center><h1>Bases Numericas</h1></center>\n\n```\nHexadecimal:\n\t0x0010A\n\nOctal:\n\t011176\n\nBinario:\n\t11011b\n```"},
		{"id":"b141d6a17aaaaf35","type":"text","text":"Caracteres:\n\n* u8'char'\n* u'char'\n* U'char'\n* L'char'\n\n* \\\\'\n* \\\\\"\n* \\\\\\\\\n* \\\\a\n* \\\\b\n* \\\\f\n* \\\\n\n* \\\\r\n* \\\\t\n* \\\\v\n\n* \\nmn => Octal\n* \\\\Xn => Hex\n* \\\\u / \\\\U => Unicode","x":440,"y":-1740,"width":480,"height":540},
		{"id":"a49919ac7590ae62","type":"text","text":"Caracteres:\n\n* u8\"char\"\n* u\"char\"\n* U\"char\"\n* L\"char\"","x":0,"y":-1820,"width":405,"height":200}
	],
	"edges":[
		{"id":"ee259dd2b67ec9c6","fromNode":"f299a149018c2211","fromSide":"left","toNode":"980c28d605817a41","toSide":"right"},
		{"id":"aeabc721262c48c1","fromNode":"fdcde377ba24196e","fromSide":"right","toNode":"5fe4440904207e8e","toSide":"left"},
		{"id":"22dcfeb188645ed8","fromNode":"5c668951377caac0","fromSide":"left","toNode":"62a31604e5a8ba08","toSide":"right"},
		{"id":"6ce629fe73fb2227","fromNode":"3c795b424b70887b","fromSide":"right","toNode":"3e31f00885d730c0","toSide":"left"},
		{"id":"31e6cdebbeb02b2a","fromNode":"fa1436b39cd15649","fromSide":"left","toNode":"0f60de72b746fb0f","toSide":"right"}
	]
}